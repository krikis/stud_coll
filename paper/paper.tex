\documentclass[journal]{vgtc}                % final (journal style)
%\documentclass[review,journal]{vgtc}         % review (journal style)
%\documentclass[widereview]{vgtc}             % wide-spaced review
%\documentclass[preprint,journal]{vgtc}       % preprint (journal style)
%\documentclass[electronic,journal]{vgtc}     % electronic version, journal

%% Uncomment one of the lines above depending on where your paper is
%% in the conference process. ``review'' and ``widereview'' are for review
%% submission, ``preprint'' is for pre-publication, and the final version
%% doesn't use a specific qualifier. Further, ``electronic'' includes
%% hyperreferences for more convenient online viewing.

%% Please use one of the ``review'' options in combination with the
%% assigned online id (see below) ONLY if your paper uses a double blind
%% review process. Some conferences, like IEEE Vis and InfoVis, have NOT
%% in the past.

%% Please note that the use of figures is not permitted on the first page
%% of the journal version.  Figures should begin on the second page and be
%% in CMYK or Grey scale format, otherwise, colour shifting may occur
%% during the printing process.  Papers submitted with figures on the
%% first page will be refused.

%% These three lines bring in essential packages: ``mathptmx'' for Type 1
%% typefaces, ``graphicx'' for inclusion of EPS figures. and ``times''
%% for proper handling of the times font family.

\usepackage{mathptmx}
\usepackage{graphicx}
\usepackage{times}

%% We encourage the use of mathptmx for consistent usage of times font
%% throughout the proceedings. However, if you encounter conflicts
%% with other math-related packages, you may want to disable it.

%% If you are submitting a paper to a conference for review with a double
%% blind reviewing process, please replace the value ``0'' below with your
%% OnlineID. Otherwise, you may safely leave it at ``0''.
\onlineid{0}

%% declare the category of your paper, only shown in review mode
\vgtccategory{Research}

%% allow for this line if you want the electronic option to work properly
\vgtcinsertpkg

%% In preprint mode you may define your own headline.
%\preprinttext{To appear in an IEEE VGTC sponsored conference.}

%% Paper title.

\title{Context Inconsistency Management \\Using Partial Constraint Checking}

%% This is how authors are specified in the journal style

%% indicate IEEE Member or Student Member in form indicated below
\author{Samuel Esposito ~~~~~~~~~~~~ Alexander Jurjens}


%% Abstract section.
\abstract{Thanks to the pervasive computing paradigm more and more computer systems in utility buildings and industry are context-aware. They use a representation of the world they operate in to reduce the human-computer interaction necessary for their operation. Unfortunately reasoning based on contexts is not without flaws and context inconsistencies are the main reason for context-aware applications' incongruous behavior. Context consistency management is not adequately studied in existing literature and approaches for detecting and resolving context conflicts are not suited for pervasive computing~\cite{xu:2010:PCC}.

In this paper we present two complementary approaches for improving the mitigation of context inconsistencies. 
First we present partial constraint checking for timely identifying context inconsistencies at runtime. An extra constraint layer is added to the traditional ontology based context model and conflicts can be detected by locally checking partial constraints in the ontology. This dramatically improves performance compared to iterative evaluation of an entire ontology~\cite{xu:2010:PCC}.
Secondly we discuss the extention of the traditional ontology model with context lifecycles to more accurately represent the environment of context-aware applications. This information can then be used to estimate the relative reliability of contexts in a conflict set and discard the contexts with lowest reliabilty~\cite{bu:2006:CCM}. 
Apart from resolving context conflicts it is also possible to represent inconsistencies into the context model itself. In this paper we explore the possibilities of incorporating inconsitencies into ontologies using fuzzy OWL and discuss the consequences of this approach on standard reasoning methods~\cite{ko:2009:IOFO}.
} % end of abstract

%% Keywords that describe your work. Will show as 'Index Terms' in journal
%% please capitalize first letter and insert punctuation after last keyword
\keywords{Pervasive Computing, Ontology Model, Context Lifecycle, Inconsistency Resolution.}

%% Copyright space is enabled by default as required by guidelines.
%% It is disabled by the 'review' option or via the following command:
% \nocopyrightspace

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%% START OF THE PAPER %%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

%% The ``\maketitle'' command must be the first command after the
%% ``\begin{document}'' command. It prepares and prints the title block.

%% the only exception to this rule is the \firstsection command
\firstsection{Introduction}

\maketitle

- WHAT\\
Conflict detection\\
Conflict resolution\\
Inconsistent ontologies\\
~\\
- WHY\\
Performance\\
Automate resolution\\
Better model context\\
~\\
- HOW\\
PCC\\
CIR\\
HMM - Fuzzy set theory\\




\section{Related Work}
Pervasive or ubiquitous computing is a fast-developing discipline that has been receiving increasing attention from both researchers and software developers~\cite{xu:2010:PCC}. In the past decade, many context-aware systems have been developed, ranging from smart room environments to warehouse and supply chain management systems. Lots of effort has been put into building middleware infrastructures that handle vast amounts of sensory data and extract the context information relevant for pervasive applications. Examples of such systems are CoBrA and CORTEX~\cite{bu:2006:CCM}. Various modeling approaches have been proposed for capturing context information, of which the ontology based context model appears to be most promising for most pervasive applications~\cite{bu:2006:CCM}.

Context management for consistency however has not been adequately studied in the existing literature. None of the studies on context-awareness discusses a way for detecting context inconsistencies for reliable pervasive computing~\cite{xu:2010:PCC, bu:2006:CCM}. Even though there has been related research going on in other disciplines as artificial intelligence and software engineering, it doesn't provide adequate support for context inconsistency detection in ubuquitous computing. In addition the strategies proposed in literature for resolving context conflicts are not suited for pervasive computing. Some are based on assumptions that may not apply to general pervasive environments. Other require human participation for conflict resolution, which is usually expensive and slow for pervasive computing~\cite{xu:2010:PCC}. Finally no research has been done on the potential of fuzzy ontologies for representing context inconsistencies in the environment instead of trying to resolve them~\cite{ko:2009:IOFO}.

In this article we aim at putting a milestone for context management by presenting an efficient inconsistency detection algorithm based on a constraint language extending the traditional ontology based context model~\cite{xu:2010:PCC}. In addition we put forward a conflict resolution algorithm which is based on a context reliability heuristic~\cite{bu:2006:CCM}. Finally the use of fuzzy ontologies representing context inconsistencies as a promising alternative to conflict resolution is explored.

\section{Partial Constraint Checking}
Constraint checking techniques have been extensively studied in software engineering. Existing constraint checking algorithms focus on checking software artifacts that do not change rapidly or frequently~\cite{xu:2010:PCC}. Context-aware applications require more efficient algorithms because they use a huge set of contexts, wich can change very rapidly and frequently (in the range of miliseconds). An inefficient software solution for this does not only require massive computing power, but interestingly also induces a higher inconsistency detection miss rate: because of the computing delay conflicting contexts slip through the context buffer before they are detected by the software~\cite{xu:2010:PCC}. One example of an inefficient approach is nonincremental checking: whenever there is a change in the set of software artifacts these artifacts are each checked against the entire set of consistency constraints to find out all detectable inconsistencies. An improvement to this would be incremental checking: only a subset of all constraints are checked, namely those that are affected by the specific change in the artifact set. But the real merit of Xu et \textit{al.} was replacing the traditional entire constraint checking approach by partial contstraint checking based on a consistency computation tree~\cite{xu:2010:PCC}. Their idea is that constraints can be represented as trees with nodes for logical operations and leaves for specific properties of contexts or context sets. Whenever a context is added to or deleted from a context set in time, the branch corresponding to this context can respectively be added to or deleted from the tree (see Fig.~\ref{fig:cct}). 
\begin{figure}[htb]
  \centering
  \includegraphics[width=3.5in]{cons_comp_tree}
  \caption{Consistency Computation Tree: branches can be added or deleted to represent changes in a context set. Source:~\cite{xu:2010:PCC}}
  \label{fig:cct}
\end{figure}
Because intermediate values are retained in the tree nodes after calculation they can be reused whenever the tree changes. More specifically, when a branch is added, only the values for the new branch itself and for the nodes from the branch top to the tree root need to be calculated. When a branch is deleted, only the values for the nodes from the branch top to the tree root have to be recalculated. 

With their partial constraint checking algorithm Xu et \textit{al.} attained a time complexity between $O(n)$ for the worst case and $O(1)$ for the best case when a context was added to the set and $O(1)$ when a context was removed. Compared to traditional constraint checking with an overall complexity of $O(n)$, this is a dramatical improvement. In their experiments Xu et \textit{al.} showed that their performance is 15 times better than the traditional approach and in a case study the inconsistency miss rate dropped from $52.2\%$ in traditional checking to $0.1\%$ with partial checking~\cite{xu:2010:PCC}.

\section{Context Inconsistency Resolution}
Now that we have an efficient method for detecting inconsistencies the task of resolving the conflicts remains. As discussed above the strategies for conflict resolution in literature are not very suited for pervasive computing because their assumptions do not apply or they require human participation~\cite{xu:2010:PCC}. What really is needed is an algorithm that in the case of a conflict between two or more contexts decides which context has the highest reliability and retains that context. Bu et \textit{al.} show us that this is possible through extending the ontology based context model with additional information about the context's status and temporal properties~\cite{bu:2006:CCM}. More specifically they propose an algorithm that for every conflict set retains the context with the highest \textit{relative frequency}: frequency of context updates relative to update interval and context age (see Fig.~\ref{fig:cir}). 
\begin{figure}[htb]
  \centering
  \includegraphics[width=3.5in]{cir}
  \caption{Context inconsistency resolution in action. Source:~\cite{bu:2006:CCM}}
  \label{fig:cir}
\end{figure}
This is based on the assumption that contexts that are most stably perceived by a system are most likely to be correct. This assumption is applicable to most of the environments in which pervasive systems run and is applied in many domains as a domain specific approach~\cite{xu:2010:PCC}.

\section{Fuzzy Ontologies}

better modeling
training required
maybe slower
extensive research necessary

HMM
Forward-backward algorithm

\section{Discussion}

\section{Conclusion}


\bibliographystyle{abbrv}
%%use following if all content of bibtex file should be shown
%\nocite{*}
\bibliography{paper}
\end{document}
